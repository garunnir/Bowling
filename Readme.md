본 문서는 볼링 점수 계산기 프로젝트의 주요 설계 원칙과 기술적 의사결정의 배경을 기술합니다. 이 문서는 프로젝트를 인계받을 동료 개발자가 코드의 구조적 의도를 빠르게 파악하고 유지보수할 수 있도록 돕는 것을 목적으로 합니다.

## 1. 아키텍처 개요: MVP (Model-View-Presenter) 패턴 적용

본 프로젝트는 뷰와 비즈니스 로직의 완전한 분리를 위해 **MVP(Model-View-Presenter)** 패턴을 채택했습니다.

- **Game (Presenter):** 사용자 입력을 받아 모델을 갱신하고, 그 결과를 뷰에 전달하는 중재자입니다.
- **StandardScoreCalculator (Model):** 볼링의 점수 계산 규칙을 보유한 순수 로직 모듈입니다. 상태를 저장하지 않고 입력에 대한 결과만 반환합니다.
- **ConsoleScoreRenderer (View):** Presenter가 전달한 데이터(DTO)를 수동적으로 출력하는 역할만 수행합니다. 모델(계산기)에 대해 전혀 알지 못합니다.

![diagram (2).jpg](attachment:248cbb21-d5c9-4ebd-8549-a787e69825c7:diagram_(2).jpg)

### 결정 이유

단순한 콘솔 앱이지만, **단위 테스트(Unit Test)의 용이성**과 **미래의 확장성**을 최우선으로 고려했습니다. MVP 패턴을 통해 뷰(View)와 로직(Model)을 인터페이스로 격리함으로써, 다음과 같은 이점을 확보했습니다.

1. **테스트 용이성:** `Console.WriteLine` 같은 UI 의존성 없이 핵심 계산 로직(`Calculator`)만 독립적으로 테스트할 수 있습니다.
2. **이식성(Portability):** 추후 유니티(Unity)나 웹으로 플랫폼이 변경되더라도, `IScoreBoardRenderer`의 구현체만 교체하면 `Game` 클래스와 `Calculator` 로직을 100% 재사용할 수 있습니다.

## 2. 데이터 무결성 및 흐름 제어

### 2.1. 가상 실행 (Dry-run) 패턴을 통한 트랜잭션 관리

잘못된 입력(예: 핀 합계 11 이상)이 들어왔을 때, 데이터를 롤백(Rollback)하는 복잡함을 피하기 위해 **'선 검증 후 커밋(Validate then Commit)'** 전략을 사용했습니다.

1. **가상 실행:** 입력값을 즉시 저장하지 않고 임시 리스트에 추가하여 계산기(`Calculator`)를 돌려봅니다.
2. **검증:** 계산기가 반환한 결과(`DTO`)에 에러 플래그가 있다면 입력을 즉시 폐기(Discard)합니다.
3. **커밋:** 에러가 없을 때만 내부 저장소에 반영하고 화면을 갱신합니다.
    
    ![diagram (1).jpg](attachment:1ab6206c-9be0-4341-81bd-1dbc149159f6:diagram_(1).jpg)
    

> Effect: 잘못된 데이터가 게임의 상태를 오염시키는 것을 원천적으로 차단하여 데이터 무결성을 보장합니다.
> 

### 2.2. 도메인 규칙의 내재화 (Domain Encapsulation)

초기에는 입력값 검증이 `Game` 클래스에 있었으나, **"유효하지 않은 입력은 시스템 에러가 아니라 게임 규칙 위반(Domain Violation)이다"**라는 판단 하에 이를 도메인 로직인 `Calculator` 내부로 이동시켰습니다. 이를 통해 계산기는 외부 의존성 없이도 스스로 데이터 무결성을 지킬 수 있는 완전한 객체가 되었습니다.

## 3. 도메인 로직의 추상화 및 시각화

### 3.1. '기회와 과업(Opportunity & Task)' 모델 도입

볼링의 규칙을 단순 분기문(`if-else`)이 아닌, **"주어진 기회(Max Tries) 안에 핀(Current Pins)을 모두 제거하는 것"**이라는 일반화된 모델로 추상화하여 구현했습니다.

![diagram.jpg](attachment:d9f5ebe9-0ba9-4d36-ab49-4ed6f2fc7f9c:diagram.jpg)

### 3.2. 프레임 처리 로직의 격리 (Isolation)

일반 프레임(1~9)과 마지막 프레임(10)은 종료 조건과 보너스 규칙이 본질적으로 다릅니다. 이를 억지로 하나의 루프에 넣지 않고 `ConsumeAndCalculateNormalFrame`과 `ConsumeAndCalculateFinalFrame` 메서드로 명확히 분리했습니다.

> Effect: 각 프레임 타입별 로직이 격리되어, 한쪽의 규칙 변경이 다른 쪽에 사이드 이펙트를 주지 않습니다. 또한 Calculate 메서드는 흐름 제어(Orchestration)에만 집중하게 되어 가독성이 향상되었습니다.
> 

## 4. 뷰와 모델의 결합도 감소 (Decoupling)

### 4.1. 명시적 프레임 타입(FrameType) 전달

DTO에 `FrameType` (Normal/Final) 속성을 추가하여, 렌더러가 "몇 번째 프레임이니까 어떻게 그려야 한다"고 **추측(Guess)**하지 않도록 설계했습니다.

### 4.2. 디버깅 편의성 확보 (Observability)

렌더러와 계산기가 분리되어 있어 문제 발생 시 원인 파악이 어려울 수 있습니다. 이를 보완하기 위해 DTO의 `ToString()`을 오버라이딩하여, 디버거 사용 시 객체 상태(점수, 핀, 에러 여부)를 직관적으로 확인할 수 있도록 구현했습니다.

---

## 5. 테스트 전략 및 품질 보증 (Testing Strategy)

### 5.1. 데이터 기반 테스트 (Data-Driven Testing)

`xUnit` 프레임워크의 `[Theory]` 기능을 활용하여 테스트를 작성했습니다. 다양한 시나리오(퍼펙트 게임, 올 거터, 엣지 케이스 등)를 코드 중복 없이 데이터 셋으로만 관리하여, 로직 변경 시 회귀 테스트(Regression Test)의 효율성을 높였습니다.

### 5.2. 블랙박스 테스트 (Black-box Testing)

내부 구현(`private` 메서드 등)에 의존하지 않고, 오직 `public` 인터페이스(`Calculate`)의 입력과 출력만을 검증했습니다. 이를 통해 내부 로직을 리팩토링하더라도 테스트 코드가 깨지지 않는 견고함을 확보했습니다.

---

## 6. 의존성 주입 (Dependency Injection)

`Game` 클래스는 구체적인 구현체(`ConsoleLogger`, `ConsoleScoreRenderer`)에 직접 의존하지 않고, 인터페이스(`ILogger`, `IScoreBoardRenderer`)에 의존합니다.

### 결정 이유

- **테스트 용이성(Testability):** 실제 콘솔 출력 없이 Mock 객체를 주입하여 로직 검증이 가능합니다.
- **확장성(Extensibility):** 추후 유니티 엔진 도입 시 `UnityLogger`, `UnityUIRenderer`로 구현체만 교체하면 `Game` 클래스의 코드 수정 없이 포팅이 가능합니다.

## 7. 제약 사항 및 한계 (Known Constraints)

- **스플릿(Split) 미구현:** 현재 입력 인터페이스(`int pins`)만으로는 핀의 물리적 배치(잔여 핀 위치)를 알 수 없어 스플릿 판정 로직은 제외했습니다. 추후 `bool[] pins` 형태의 입력이 도입된다면 확장이 가능합니다.

---

# AI 기술 사용 명세 (AI Usage Specification)

본 프로젝트는 생성형 AI(Generative AI)를 단순 코드 생성기가 아닌 **'페어 프로그래밍 파트너'**로 활용하였으며, 협업의 구체적인 내역은 다음과 같습니다.

### 1. AI 기술을 활용한 결과물

- **기반 코드:** `ScoreFrameDTO`, `IScoreCalculator` 등 인터페이스 및 데이터 구조의 초안.
- **렌더링 테크닉:** `ConsoleScoreRenderer` 구현 시, 콘솔의 고정폭 폰트 특성을 이용한 **'텍스트 패딩(Padding) 및 정렬 알고리즘'** (AI 제안 기술 습득 및 적용).
- **시각화 자료:** 문서 내 포함된 아키텍처 다이어그램(Class), 트랜잭션 시퀀스(Sequence), 로직 흐름도(Flowchart)의 **Mermaid 그래프 코드 생성**.
- **문서화:** 본 설계 문서의 초안 작성 및 기술 용어 정제.

### 2. AI 활용 이유 및 효과

- **설계 확신 확보 (Confidence):** "이 방식으로 구현하는 것이 맞을까?"라는 지속적인 질문을 통해 설계의 타당성을 검증받고, 확신을 가지고 구현을 진행할 수 있었습니다.
- **문서 전달력 강화:** 복잡한 로직이나 데이터 흐름을 텍스트로만 설명하는 대신, AI를 활용해 다이어그램으로 시각화함으로써 문서의 가독성과 인수인계 효율을 높였습니다.
- **기술적 습득:** 익숙하지 않았던 텍스트 포맷팅 기법이나 인터페이스 분리 패턴 등을 AI가 생성한 예시 코드를 통해 학습하고 프로젝트에 적용했습니다.

### 3. 지원자가 직접 수행한 영역 (Human in the Loop)

AI의 제안을 비판적으로 수용하고, **설계적 결함이나 도메인 규칙의 오해를 바로잡는 역할**은 전적으로 지원자가 수행했습니다.

- **도메인 규칙의 재정립 (Logic Correction):**
AI가 제안한 초기 로직에서 핀 갯수 초과나 10프레임 투구 수 오류 등의 버그가 발생했습니다. 이는 AI와 지원자가 이해한 규칙의 차이에서 비롯된 것임을 파악하고, **`RemainPins`와 `Throws` 변수를 도입**하여 물리적 규칙을 코드에 강제함으로써 문제를 해결했습니다.
- **아키텍처 원칙 준수 (Architectural Integrity):**
AI가 생성한 계산 로직(`Calculator`) 내부에 `Console.WriteLine`이 포함되어 있는 것을 발견하고, **"계산 로직은 입출력(IO)에 의존해선 안 된다"**는 SoC 원칙에 따라 출력을 제거하고 순수 로직으로 정제했습니다.
- **데이터 모델링 최적화:**
DTO 설계 시 불필요한 연산 로직을 배제하고, 렌더링에 필요한 최소한의 정보만을 담도록 제한하여 뷰와 모델의 결합도를 낮췄습니다.

### 4. 협업 시너지: 기술적 통찰의 교류 (Technical Insight Exchange)

- **상태 관리 방식에 대한 재검토 (`ref` keyword):**
초기 메서드 분리 시 AI가 `ref` 키워드를 사용한 것에 대해 이견이 있었으나, 볼링 점수 계산의 특성상 **'미래의 투구 결과(Look-ahead)를 참조해야 하는 연속성'**이 중요함을 깨닫고, 객체 생성 비용을 줄이는 `ref` 방식의 효율성을 이해하고 채택했습니다.
- **렌더링 포맷팅 기법의 습득 (Rendering Optimization):**
프레임 번호 자릿수(`1:` vs `10:`) 차이로 인해 콘솔 출력 정렬이 어긋나는 문제가 발생했습니다. 이를 해결하기 위해 AI가 제안한 `String.PadRight`를 활용한 **고정폭 패딩(Fixed-width Padding) 기법**을 학습하고 적용하여, 일관된 UI 정렬을 완성했습니다.
- **테스트 자동화 기법 습득 (Unit Testing):**
단순한 `[Fact]` 기반 테스트를 넘어, `[Theory]`와 `[InlineData]`를 활용한 데이터 기반 테스트 기법을 AI를 통해 습득하고 적용했습니다. 이를 통해 로직 변경 시에도 다양한 시나리오를 효율적으로 검증할 수 있는 체계를 구축했습니다.
